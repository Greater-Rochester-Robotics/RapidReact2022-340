// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands.drive.auto;

import com.pathplanner.lib.PathPlanner;
import com.pathplanner.lib.PathPlannerTrajectory;
import com.pathplanner.lib.PathPlannerTrajectory.PathPlannerState;

import edu.wpi.first.math.controller.HolonomicDriveController;
import edu.wpi.first.math.controller.PIDController;
import edu.wpi.first.math.controller.ProfiledPIDController;
import edu.wpi.first.math.geometry.Pose2d;
import edu.wpi.first.math.geometry.Rotation2d;
import edu.wpi.first.math.kinematics.ChassisSpeeds;
import edu.wpi.first.math.trajectory.Trajectory;
import edu.wpi.first.math.trajectory.TrapezoidProfile;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj2.command.CommandBase;

import frc.robot.Constants;
import frc.robot.RobotContainer;
import frc.robot.subsystems.ADIS.IMUAxis;

/**
 * This command takes a file name as an arguement. It will 
 * then attempt to run said path by generating a trajectory 
 * from the path parameters in said file. PID values are 
 * from the Constants file. 
 */
public class DriveFollowTrajectory extends CommandBase {
  //timer for the running of the path
  Timer timer;

  //space for the trajectory, generated from the pathfile
  PathPlannerTrajectory trajectory;

  //mutli part PID controller made of the following PID controllers
  HolonomicDriveController pathController;
  static PIDController xController;
  static PIDController yController;
  static ProfiledPIDController rotationController;

  //whether of not this command resets the odometry to the starting point
  boolean resetOdometry;

  /**
   * Run the path with default MaxVelocity, MaxAcceleration
   * Did you remember to set the gyro at the start of the 
   * autonmomous to mathc the starting point found in here
   * 
   * @param pathFileName name of the file generated by pathplanner
   */
  public DriveFollowTrajectory(String pathFileName) {
    this(pathFileName, Constants.PATH_MAXIMUM_VELOCITY, Constants.MAXIMUM_ACCELERATION);
  }

  public DriveFollowTrajectory(String pathFileName, double maxVel, double maxAccel) {
    this(pathFileName, maxVel, maxAccel, true);
  }

  public DriveFollowTrajectory(String pathFileName, double maxVel, double maxAccel, boolean resetOdometry) {
    //require the swerveDrive subsystem
    addRequirements(RobotContainer.swerveDrive);

    //construct the timer
    this.timer = new Timer();

    //generate a trajectory from the path in the given file given the filename, max velocity and max acceleration.
    this.trajectory = PathPlanner.loadPath(pathFileName, maxVel, maxAccel);

    //setup PID controllers for the xPostion on the field, the yPostion on the field, and the rotation of the robot
    xController = new PIDController(Constants.DRIVE_POS_ERROR_CONTROLLER_P, Constants.DRIVE_POS_ERROR_CONTROLLER_I, Constants.DRIVE_POS_ERROR_CONTROLLER_D);
    yController = new PIDController(Constants.DRIVE_POS_ERROR_CONTROLLER_P, Constants.DRIVE_POS_ERROR_CONTROLLER_I, Constants.DRIVE_POS_ERROR_CONTROLLER_D);
    rotationController = new ProfiledPIDController(Constants.DRIVE_ROTATION_CONTROLLER_P, Constants.DRIVE_ROTATION_CONTROLLER_I, Constants.DRIVE_ROTATION_CONTROLLER_D,
            new TrapezoidProfile.Constraints(Constants.DRIVE_MAX_ANGULAR_VELOCITY, Constants.DRIVE_MAX_ANGULAR_ACCEL));
    
    // rotationController.enableContinuousInput(-Math.PI, Math.PI);// our gyro isn't discontinous
    rotationController.disableContinuousInput();//our gyro isn't discontinous

    //pass the three PID controllers into the one drive controller
    this.pathController = new HolonomicDriveController(xController, yController, rotationController);

    //pass this value out of constructor
    this.resetOdometry = resetOdometry;
  }

  // Called when the command is initially scheduled.
  @Override
  public void initialize() {
    RobotContainer.swerveDrive.setGyroAxis(IMUAxis.kY);
    //make sure odometry is on
    RobotContainer.swerveDrive.setIsOdometry(true);

    //start the timer, this must be reset also
    timer.reset();
    timer.start();

    //poll the trajectory to find the first point
    PathPlannerState initialState = (PathPlannerState) trajectory.sample(0.0);

    //reset the PID controllers, zero the I error, etc.
    xController.reset();
    yController.reset();
    rotationController.reset(initialState.holonomicRotation.getDegrees());

    //if we need to reset odometry...
    if(resetOdometry) {
      //set the current position to the expected pose fromt he trajectory
      RobotContainer.swerveDrive.setCurPose2d(new Pose2d(initialState.poseMeters.getTranslation(),RobotContainer.swerveDrive.getGyroRotation2d()));
      // RobotContainer.swerveDrive.setGyro(initialState.holonomicRotation.getDegrees());//safer to use the DriveSetGyro command
    }
  }

  // Called every time the scheduler runs while the command is scheduled.
  @Override
  public void execute() {
    //poll the current time
    double time = timer.get();

    //based on the current time, find where the trajectory says the robot should be
    PathPlannerState desiredState = (PathPlannerState) trajectory.sample(time);
    
    //using the desiredState and the currentState, use the pathController to find the speeds the robot should be going
    ChassisSpeeds robotSpeed = pathController.calculate(RobotContainer.swerveDrive.getCurPose2d(), desiredState, desiredState.holonomicRotation);
    //pass the robotSpeed to the swerveDrive
    RobotContainer.swerveDrive.driveRobotCentric(robotSpeed, true, false);

    // Position Graph For Testing
    // SmartDashboard.putNumber("PIDTarget", desiredState.getPos());
    // SmartDashboard.putNumber("PIDActual", pathController.getTotalDistance());

    // // Heading Graph For Testing
    // SmartDashboard.putNumber("PIDTarget", desiredState.getHeading().getDegrees());
    // SmartDashboard.putNumber("PIDActual", pathController.getCurrentHeading().getDegrees());

    // Rotation Graph For Testing
    // SmartDashboard.putNumber("PIDTarget", desiredState.getRotation().getDegrees());
    // SmartDashboard.putNumber("PIDActual", RobotContainer.swerveDrive.getCurPose2d().getRotation().getDegrees());
  }

  // Called once the command ends or is interrupted.
  @Override
  public void end(boolean interrupted) {
    timer.stop();

    //stop the robot as we are done with the path.
    RobotContainer.swerveDrive.driveRobotCentric(0, 0, 0, true, false);
  }

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    //when we have finished the time the path takes, end the command
    return timer.hasElapsed(trajectory.getTotalTimeSeconds());
  }
}
